"use strict";
var Rx_1 = require('rxjs/Rx');
var core_1 = require('@angular/core');
var http_1 = require('@angular/http');
var HttpClient = (function () {
    function HttpClient(http) {
        this.http = http;
        this.beforeHooks = [];
        this.afterHooks = [];
    }
    HttpClient.prototype.init = function (baseUrl) {
        this.baseUrl = baseUrl;
    };
    HttpClient.prototype.get = function (url, options) {
        var opts = this.build(http_1.RequestMethod.Get, url, options);
        return this.request(url, opts);
    };
    HttpClient.prototype.put = function (url, body, options) {
        var opts = this.build(http_1.RequestMethod.Put, url, options, body);
        return this.request(url, opts);
    };
    HttpClient.prototype.post = function (url, body, options) {
        var opts = this.build(http_1.RequestMethod.Post, url, options, body);
        return this.request(url, opts);
    };
    HttpClient.prototype.delete = function (url, options) {
        var opts = this.build(http_1.RequestMethod.Delete, url, options);
        return this.request(url, opts);
    };
    HttpClient.prototype.patch = function (url, body, options) {
        var opts = this.build(http_1.RequestMethod.Patch, url, options, body);
        return this.request(url, opts);
    };
    HttpClient.prototype.request = function (url, options) {
        var _this = this;
        var req;
        if (typeof url === 'string') {
            var reqOpt = new http_1.RequestOptions(options);
            reqOpt.url = url;
            req = new http_1.Request(reqOpt);
        }
        else {
            req = url;
        }
        return this.beforeRequest(req)
            .flatMap(function (req) { return _this.http.request(req); })
            .map(function (res) { return _this.afterCall(res); });
    };
    HttpClient.prototype.build = function (method, url, options, body) {
        var aBody = body ? body : options && options.body ? options.body : undefined;
        var opts = {
            method: method,
            url: url,
            headers: options && options.headers ? options.headers : new http_1.Headers(),
            search: options && options.search ? options.search : undefined,
            body: aBody
        };
        return opts;
    };
    HttpClient.prototype.addBeforeHook = function (func) {
        this.beforeHooks.push(func);
    };
    HttpClient.prototype.addAfterHook = function (func) {
        this.afterHooks.push(func);
    };
    HttpClient.prototype.beforeRequest = function (req) {
        if (this.baseUrl) {
            req.url = this.baseUrl + "/" + req.url;
        }
        if (this.beforeHooks.length) {
            return Rx_1.Observable.fromPromise(this.beforeHooks.reduce(function (previousValue, currentValue) {
                return previousValue
                    .then(function (res) {
                    return currentValue(res);
                });
            }, Promise.resolve(req)));
        }
        else {
            return Rx_1.Observable.of(req);
        }
    };
    HttpClient.prototype.afterCall = function (res) {
        this.afterHooks.forEach(function (hook) {
            res = hook(res);
        });
        return res;
    };
    HttpClient.decorators = [
        { type: core_1.Injectable },
    ];
    /** @nocollapse */
    HttpClient.ctorParameters = [
        { type: http_1.Http, },
    ];
    return HttpClient;
}());
exports.HttpClient = HttpClient;
